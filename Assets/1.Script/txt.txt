--------------------------------------------------------------------------




저장 해야하는 거
저장은 너 하고싶을떄 언제든 돼

캐릭터 위치
인벤토리
HP
능력치
대화스크립트
파괴된오브젝트
동상눈까리
퀘스트 진행상황
보스를 처음잡았는지 변수
















		[기능구현]

사운드 조절 기능
게임 저장 기능 구현 ☆중요☆





		[참고자료]
포스트프로세싱 https://www.youtube.com/watch?v=m-6QjaDfigs&t=120s
인벤토리 https://geojun.tistory.com/62
타일맵 팔레트 https://blog.naver.com/pxkey/221298663537
탑다운 게임 https://www.youtube.com/watch?v=9zzUq6T-rtA&list=PL6bqhqO0Ba776ksb3F9P_xmUMT9WvmfFT
맵 이동 및 변경 https://jjong-ga.tistory.com/104
버츄얼 https://zprooo915.tistory.com/11
오버라이드 https://luv-n-interest.tistory.com/791
사운드 https://daegwonkim.tistory.com/155
오브젝트 뒤로 이동 시 투명도 https://www.youtube.com/watch?v=0HBHiJRb0zU
이진공간분할법 https://sharp2studio.tistory.com/45
다이얼로그 https://studybacksu.tistory.com/11
		   https://wjs991.tistory.com/29
		   https://make-my-jazz.tistory.com/27


		[에셋스토어]
타일맵 https://pixivan.itch.io/top-down-forest-tileset
스토어 https://unityassetcollection.com/
스토어 https://itch.io/


던전 퀴즈 실패 시
다이얼로그 띄우기
플레이어 돌아가는? 이팩트 추가



--------------------------------------------------------------------------
          using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

[System.Serializable]
public class DialogueState
{
    public int currentChapterIndex = 0; // 현재 챕터 인덱스
    public int currentDialogueIndex = 0; // 현재 대화 인덱스
    public int currentContextIndex = 0; // 현재 대사 인덱스
}

public class Dialog : MonoBehaviour
{
    [SerializeField] private DialogueData dialogueData; // 스크립터블 오브젝트, 대화 데이터를 담고 있음
    [SerializeField] private GameObject textBox; // 대화 UI 패널
    [SerializeField] private Text context; // 대사를 표시할 텍스트
    [SerializeField] private GameObject nameBox; // 캐릭터 이름을 표시할 UI 패널
    [SerializeField] private Text characterName; // 캐릭터의 이름을 표시할 텍스트
    [SerializeField] private Image characterImg; // 캐릭터의 이미지 스프라이트를 담을 Image

    private DialogueState dialogueState; // 대화 상태 저장 클래스

    private bool isTyping = false; // 타이핑 모션 활성화 여부
    private Coroutine typingCoroutine; // 타이핑 모션 코루틴

    [SerializeField] private int currentChapterNum; // 지정된 챕터 번호 변수

    private void Awake()
    {
        dialogueState = new DialogueState(); // 대화 상태 초기화
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.E))
        {
            if (isTyping)
            {
                StopTyping(); // 타이핑 모션 중이면 즉시 종료
            }
            else
            {
                DialogueStart(); // 타이핑 모션 중이 아니면 다음 대화로 넘어감
            }
        }
    }

    private void ONOFF(bool _flag) // 대화 UI의 활성화/비활성화 설정
    {
        textBox.SetActive(_flag); // 텍스트 박스 활성화/비활성화
        context.gameObject.SetActive(_flag); // 대사 텍스트 활성화/비활성화
        nameBox.SetActive(_flag); // 네임 박스 활성화/비활성화
        characterName.gameObject.SetActive(_flag); // 캐릭터 이름 텍스트 활성화/비활성화
        characterImg.gameObject.SetActive(_flag); // 캐릭터 이미지 활성화/비활성화
    }

    public void DialogueStart() // 대화 시작
    {
        ONOFF(true); // 대화 UI 활성화

        if (currentChapterNum < dialogueData.chapters.Length) // 지정된 챕터 번호가 유효한지 확인
        {
            Chapters chapters = dialogueData.chapters[currentChapterNum]; // 지정된 챕터 가져오기

            if (dialogueState.currentDialogueIndex < chapters.dialogues.Length)
            {
                Dialogue dialogue = chapters.dialogues[dialogueState.currentDialogueIndex];

                // Dialogue의 속성들을 변수에 할당
                characterName.text = dialogue.Name; // 캐릭터 이름 설정
                characterImg.sprite = dialogue.Img; // 캐릭터 이미지 설정
                string[] contextTexts = dialogue.contexts; // 대사 텍스트 배열

                // 대사 출력
                if (dialogueState.currentContextIndex < contextTexts.Length)
                {
                    if (typingCoroutine != null)
                    {
                        StopCoroutine(typingCoroutine); // 이전 타이핑 모션 중지
                    }
                    typingCoroutine = StartCoroutine(TypeText(contextTexts[dialogueState.currentContextIndex])); // 타이핑 모션 시작
                    dialogueState.currentContextIndex++; // 다음 대사 인덱스로 이동
                }
                else
                {
                    dialogueState.currentDialogueIndex++; // 다음 대화 인덱스로 이동
                    dialogueState.currentContextIndex = 0; // 대사 인덱스 초기화

                    if (dialogueState.currentDialogueIndex < chapters.dialogues.Length)
                    {
                        DialogueStart(); // 다음 대화로 넘어가서 다시 시작
                    }
                    else
                    {
                        ONOFF(false); // 대화가 모두 끝나면 UI 비활성화
                        dialogueState.currentDialogueIndex = 0; // 변수 초기화
                        dialogueState.currentContextIndex = 0; // 변수 초기화
                    }
                }
            }
            else
            {
                ONOFF(false); // 대화가 모두 끝나면 UI 비활성화
                dialogueState.currentDialogueIndex = 0; // 변수 초기화
                dialogueState.currentContextIndex = 0; // 변수 초기화
            }
        }
        else
        {
            ONOFF(false); // 모든 챕터가 끝나면 UI 비활성화
            dialogueState.currentChapterIndex = 0; // 변수 초기화
            dialogueState.currentDialogueIndex = 0; // 변수 초기화
            dialogueState.currentContextIndex = 0; // 변수 초기화
        }
    }

    private IEnumerator TypeText(string textToType) // 타이핑 모션 실행
    {
        isTyping = true; // 타이핑 모션 활성화
        context.text = ""; // 대사 텍스트 초기화
        foreach (char letter in textToType)
        {
            context.text += letter; // 한 글자씩 추가
            yield return new WaitForSeconds(0.1f); // 타이핑 모션 속도
        }
        isTyping = false; // 타이핑 모션 비활성화
    }

    private void StopTyping() // 타이핑 모션 종료
    {
        if (typingCoroutine != null)
        {
            StopCoroutine(typingCoroutine); // 타이핑 모션 코루틴 중지
            typingCoroutine = null;
        }
        isTyping = false; // 타이핑 모션 비활성화
        // 마지막 대사 텍스트 전체 출력
        context.text = dialogueData.chapters[currentChapterNum].dialogues[dialogueState.currentDialogueIndex].contexts[dialogueState.currentContextIndex - 1];
    }

    public void SetChapterNum(int chapterNum) // 챕터 번호 설정 메서드
    {
        currentChapterNum = chapterNum; // 현재 챕터 번호 설정
        dialogueState.currentChapterIndex = chapterNum; // 대화 상태의 현재 챕터 인덱스 설정
        dialogueState.currentDialogueIndex = 0; // 대화 인덱스 초기화
        dialogueState.currentContextIndex = 0; // 대사 인덱스 초기화
    }
}

// Dialog dialogScript;
// dialogScript = FindObjectOfType<Dialog>();
// 다른 스크립트나 UI 버튼에서 챕터 번호 설정 및 대화 시작
// dialog.SetChapterNum(2); //예시 : 2번 챕터로 변경
// dialog.DialogueStart(); //대화 시작

--------------------------------------------------------------------------





엘리나는 활을 휘두르며 전설 속의 마법의 숲으로 들어섰다.
그곳은 옛날부터 숲의 수호자로 알려진 나무몬스터들의 고향이었다.
그러나 숲은 인간들의 무차별한 자연 파괴로 인해 위협받고 있었다.
나무들은 벌써 저주에 걸려 무서운 몬스터로 변했고,
 그중 일부는 분노로 인해 사람들을 공격하기 시작했다.
그녀는 숲의 수호자들과 대립하면서도 그들의 분노를 진정하고,
마법의 숲에 평화를 되찾기 위해 여정을 떠났다.
하지만 그녀의 길은 강력한 마법과 수호자들의 분노로 가로막혔는데...



세부 시나리오: "어둠의 포식자"

챕터 1: 고향의 붕괴
시작: 평화로운 마을, 브라이트헤이븐에서 게임이 시작됩니다. 엘리나는 마을을 순찰하며 기본적인 조작법과 전투 시스템을 배우게 됩니다.
이벤트: 마을 축제 중 갑작스럽게 몬스터들이 공격해오고, 엘리나는 마을 주민들을 보호하며 싸워야 합니다.
목표: 마을을 방어하고 남은 생존자들을 피난시키며, 엘리나의 가족이 어둠의 포식자에 의해 희생당하는 장면이 나옵니다.
결과: 엘리나는 복수를 다짐하고, 마을의 장로로부터 어둠의 포식자에 대한 정보를 듣고 여정을 떠납니다.


챕터 2: 첫 번째 동료
시작: 엘리나는 첫 번째 목적지인 실버우드 숲으로 향합니다. 이곳은 다양한 몬스터들이 서식하며, 엘리나의 첫 전투 훈련장이 됩니다.
이벤트: 숲에서 엘리나는 몬스터에게 습격당한 마법사 릴리아를 구출합니다. 릴리아는 강력한 마법을 사용하는 동료로, 엘리나의 여정에 합류합니다.
목표: 숲의 던전을 클리어하고, 릴리아와 함께 보스를 처치하여 중요한 아이템을 획득합니다.
결과: 릴리아는 엘리나에게 아이템 조합에 대한 지식을 전수합니다. 함께 여정을 이어갑니다.


챕터 3: 전설의 무기
시작: 엘리나와 릴리아는 드워프 왕국으로 향합니다. 이곳에는 전설적인 무기를 만들 수 있는 대장장이가 있습니다.
이벤트: 드워프 왕국은 어둠의 세력에 의해 공격받고 있습니다. 엘리나와 릴리아는 왕국을 지키기 위해 싸우게 됩니다.
목표: 드워프 왕국의 던전을 탐험하고, 재료를 모아 전설의 무기를 만듭니다. 이 과정에서 드워프 전사 볼트가 동료로 합류합니다.
결과: 전설의 활과 화살을 만들고, 엘리나는 한층 더 강해집니다.


챕터 4: 숨겨진 비밀
시작: 엘리나와 동료들은 고대 유적으로 향합니다. 이곳에는 어둠의 포식자의 비밀이 숨겨져 있습니다.
이벤트: 유적에서 고대의 수호자를 만나고, 그의 도움으로 어둠의 포식자에 대한 정보를 얻습니다.
목표: 고대 유적의 퍼즐을 풀고, 보스를 처치하여 강력한 마법 아이템을 획득합니다.
결과: 어둠의 포식자가 고대 마법을 통해 부활했으며, 이를 저지할 방법을 알게 됩니다.


챕터 5: 최후의 전투 준비
시작: 엘리나와 동료들은 어둠의 성채로 향합니다. 이곳은 어둠의 세력의 본거지입니다.
이벤트: 성채로 가는 길은 몬스터들로 가득 차 있으며, 엘리나는 동료들과 함께 길을 뚫고 나아갑니다.
목표: 성채의 각 층을 클리어하고, 강력한 적들을 처치하며 최종 전투를 준비합니다.
최종 전투 전에는 각 동료들의 서브 퀘스트를 완료하여 그들의 능력을 극대화시킵니다.
결과: 모든 준비를 마치고, 엘리나는 최종 보스와의 대결을 앞두게 됩니다.


챕터 6: 어둠의 포식자
시작: 엘리나는 동료들과 함께 어둠의 포식자가 있는 최종 보스 룸에 도착합니다.
이벤트: 어둠의 포식자는 엘리나에게 가족과 친구들의 죽음을 회상하게 하며, 그녀의 정신을 흔들려고 합니다.
목표: 동료들과 협력하여 어둠의 포식자의 다양한 공격 패턴을 분석하고, 최적의 전략으로 그를 물리칩니다.
결과: 어둠의 포식자를 처치하고, 엘리오스에 평화를 되찾습니다. 엘리나는 마을로 돌아와 새로운 시작을 다짐합니다.


에필로그:
엘리나는 어둠의 세력을 물리치고, 엘리오스는 다시 평화를 되찾습니다. 엘리나는 마을의 영웅으로 추대되며,
여정 중 만난 동료들과 함께 새로운 시대를 열어갑니다. 릴리아와 볼트는 각각 자신의 길을 찾아 떠나지만,
그들의 우정은 계속됩니다. 엘리나는 가족과 친구들의 희생을 기리며, 더 나은 미래를 위해 계속해서 싸워나갈 것을 다짐합니다.